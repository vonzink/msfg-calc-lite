/**
 * Variable Income Engine (Fannie-aligned)
 * Core references:
 * - B3-3.1-01 (variable income history + trending + continuity)
 * - B3-3.1-03 (bonus/overtime 12mo min; compare calculations to YTD)
 * - B3-3.1-04 (commission history guidance)
 *
 * NOTE: This engine is a rules framework. You’ll feed it paystub + W-2 extracted data.
 */

/** @typedef {"SALARY"|"HOURLY"} BasePayType */
/** @typedef {"WEEKLY"|"BIWEEKLY"|"SEMIMONTHLY"|"MONTHLY"} PayFrequency */
/** @typedef {"PURCHASE"|"LCO_REFI"|"CO_REFI"} LoanPurpose */

/**
 * @typedef {Object} PaystubYTD
 * @property {number} baseYTD
 * @property {number} overtimeYTD
 * @property {number} bonusYTD
 * @property {number} commissionYTD
 * @property {number} otherYTD
 * @property {number} payPeriodsYTD
 * @property {string} asOfDateISO  // e.g. "2026-02-16"
 */

/**
 * @typedef {Object} PriorYearEarnings
 * @property {number} year
 * @property {number} base
 * @property {number} overtime
 * @property {number} bonus
 * @property {number} commission
 */

/**
 * @typedef {Object} BorrowerEmployment
 * @property {BasePayType} basePayType
 * @property {PayFrequency} payFrequency
 * @property {number} baseRate              // salary annual if SALARY; hourly rate if HOURLY
 * @property {number|null} expectedHoursPerWeek // null if salary; if hourly, 40 vs variable etc
 * @property {boolean} hoursFluctuate       // true => treat hourly base as variable averaging candidate
 * @property {string|null} startDateISO
 * @property {string|null} lastCompChangeDateISO // optional
 */

/**
 * @typedef {Object} VariableIncomeInput
 * @property {BorrowerEmployment} employment
 * @property {PaystubYTD} paystubYTD
 * @property {PriorYearEarnings[]} priorYears  // usually last 2 years
 * @property {number|null} baseNetLTVForMMI // not used here yet; reserved for your full tool suite
 */

/**
 * @typedef {Object} IncomeDecision
 * @property {number} monthlyBase
 * @property {number} monthlyOvertime
 * @property {number} monthlyBonus
 * @property {number} monthlyCommission
 * @property {number} monthlyTotal
 * @property {Array<{type:string, amount:number, note:string}>} breakdown
 * @property {Array<{severity:"info"|"warn"|"stop", code:string, message:string}>} flags
 */

const PAY_PERIODS_PER_YEAR = {
  WEEKLY: 52,
  BIWEEKLY: 26,
  SEMIMONTHLY: 24,
  MONTHLY: 12
};

function monthsElapsedInYear(asOfDateISO) {
  const d = new Date(asOfDateISO + "T00:00:00");
  // Use month index + 1 as a simple underwriting-style proxy.
  // If you want precision: compute days elapsed / 30.416.
  return d.getMonth() + 1;
}

function safeDiv(num, den) {
  return den === 0 ? 0 : num / den;
}

/**
 * Trend evaluation per B3-3.1-01:
 * - stable/increasing => average
 * - declining but stabilized => use current lower amount
 * - declining => may not be stable; do not average across decline period
 */
function evaluateTrend({ currentMonthly, priorYearMonthlyAvg, twoYearMonthlyAvg }) {
  const eps = 0.01;
  const stableVsTwoYear = currentMonthly + eps >= twoYearMonthlyAvg;
  const stableVsPrior = currentMonthly + eps >= priorYearMonthlyAvg;

  if (stableVsTwoYear && stableVsPrior) return { status: "STABLE_OR_UP", use: "AVERAGE" };
  if (!stableVsTwoYear && stableVsPrior) return { status: "DECLINED_THEN_STABLE", use: "CURRENT_LOWER" };
  return { status: "DECLINING", use: "REQUIRES_MANUAL_REVIEW" };
}

function calcExpectedBaseYTD(employment, paystubYTD) {
  const periods = PAY_PERIODS_PER_YEAR[employment.payFrequency];
  if (!periods) return null;

  if (employment.basePayType === "SALARY") {
    const perPeriod = employment.baseRate / periods;
    return perPeriod * paystubYTD.payPeriodsYTD;
  }

  // HOURLY
  if (!employment.expectedHoursPerWeek) return null;
  const weekly = employment.baseRate * employment.expectedHoursPerWeek;
  // Map frequency to average period hours:
  const perPeriod =
    employment.payFrequency === "WEEKLY" ? weekly :
    employment.payFrequency === "BIWEEKLY" ? weekly * 2 :
    employment.payFrequency === "SEMIMONTHLY" ? weekly * (52 / 24) :
    weekly * (52 / 12);

  return perPeriod * paystubYTD.payPeriodsYTD;
}

function ytdToMonthly(ytd, asOfDateISO) {
  const m = monthsElapsedInYear(asOfDateISO);
  return safeDiv(ytd, m);
}

function annualToMonthly(annual) {
  return annual / 12;
}

/**
 * Main decision function
 * @param {VariableIncomeInput} input
 * @returns {IncomeDecision}
 */
export function determineUsableIncome(input) {
  const flags = [];
  const breakdown = [];

  const { employment, paystubYTD, priorYears } = input;

  const monthsElapsed = monthsElapsedInYear(paystubYTD.asOfDateISO);
  if (monthsElapsed < 1) {
    flags.push({ severity: "stop", code: "BAD_DATE", message: "Invalid as-of date." });
    return { monthlyBase: 0, monthlyOvertime: 0, monthlyBonus: 0, monthlyCommission: 0, monthlyTotal: 0, breakdown, flags };
  }

  // --- Base income ---
  let monthlyBase = 0;

  if (employment.basePayType === "SALARY") {
    monthlyBase = annualToMonthly(employment.baseRate);
    breakdown.push({ type: "BASE", amount: monthlyBase, note: "Salary base pay (annual/12)." });
  } else {
    // Hourly base
    // If hours fluctuate, treat as variable income per B3-3.1-01 (averaging/trending).
    if (employment.hoursFluctuate) {
      const currentMonthly = ytdToMonthly(paystubYTD.baseYTD, paystubYTD.asOfDateISO);

      const py = priorYears[0]; // most recent prior year
      const pyMonthly = py ? (py.base / 12) : 0;
      const twoYearMonthly = priorYears.length >= 2 ? ((priorYears[0].base + priorYears[1].base) / 24) : pyMonthly;

      const trend = evaluateTrend({ currentMonthly, priorYearMonthlyAvg: pyMonthly, twoYearMonthlyAvg: twoYearMonthly });

      if (priorYears.length === 0) {
        flags.push({ severity: "warn", code: "NO_PRIOR_YEARS_BASE", message: "Hourly hours fluctuate but no prior-year earnings provided for trending." });
        monthlyBase = currentMonthly; // conservative fallback
      } else if (trend.use === "AVERAGE") {
        monthlyBase = twoYearMonthly;
      } else if (trend.use === "CURRENT_LOWER") {
        monthlyBase = currentMonthly;
      } else {
        monthlyBase = currentMonthly;
        flags.push({ severity: "warn", code: "BASE_DECLINING", message: "Hourly base appears declining; manual review recommended." });
      }

      breakdown.push({ type: "BASE", amount: monthlyBase, note: "Hourly base with fluctuating hours (variable/trended)." });
    } else {
      // fixed hours: can use rate * hours
      if (!employment.expectedHoursPerWeek) {
        flags.push({ severity: "stop", code: "MISSING_HOURS", message: "Hourly base requires expected hours/week if not fluctuating." });
      } else {
        monthlyBase = (employment.baseRate * employment.expectedHoursPerWeek * 52) / 12;
        breakdown.push({ type: "BASE", amount: monthlyBase, note: "Hourly base with stable hours." });
      }
    }
  }

  // --- Expected vs actual YTD consistency check (B3-3.1-03 guidance) ---
  const expectedBaseYTD = calcExpectedBaseYTD(employment, paystubYTD);
  if (expectedBaseYTD != null && paystubYTD.baseYTD > 0) {
    const variance = (paystubYTD.baseYTD - expectedBaseYTD) / expectedBaseYTD;
    const absVar = Math.abs(variance);

    if (absVar >= 0.05) {
      flags.push({
        severity: "warn",
        code: "YTD_BASE_VARIANCE",
        message: `Base YTD differs from expected by ${(variance * 100).toFixed(1)}%. Possible gap/unpaid leave/comp change.`
      });
    }
  }

  // --- Variable components: overtime, bonus, commission ---
  // History gates:
  // - Bonus/OT: >= 12 months to be considered stable (B3-3.1-03)
  // - Commission: 2 years recommended; 12-24 months possible w/ positive factors (B3-3.1-04, B3-3.1-01)

  function calcVariableComponent(name, ytdValue, getPriorAnnual) {
    const currentMonthly = ytdToMonthly(ytdValue, paystubYTD.asOfDateISO);
    const py = priorYears[0];
    const pyMonthly = py ? getPriorAnnual(py) / 12 : 0;
    const twoYearMonthly = priorYears.length >= 2 ? (getPriorAnnual(priorYears[0]) + getPriorAnnual(priorYears[1])) / 24 : pyMonthly;

    const trend = evaluateTrend({ currentMonthly, priorYearMonthlyAvg: pyMonthly, twoYearMonthlyAvg: twoYearMonthly });

    if (priorYears.length === 0) return { monthly: currentMonthly, trend, note: "No prior-year data; using current YTD pace." };

    if (trend.use === "AVERAGE") return { monthly: twoYearMonthly, trend, note: "Stable/increasing; using 2-year average." };
    if (trend.use === "CURRENT_LOWER") return { monthly: currentMonthly, trend, note: "Declined but stabilized; using current lower amount." };

    return { monthly: currentMonthly, trend, note: "Declining; using current pace with manual review flag." };
  }

  // Overtime
  let monthlyOvertime = 0;
  if (paystubYTD.overtimeYTD > 0) {
    // Gate: at least 12 months history recommended; we approximate by presence of prior year data.
    if (priorYears.length === 0) {
      flags.push({ severity: "warn", code: "OT_HISTORY_UNKNOWN", message: "Overtime present but no prior year provided; underwriting may require history." });
    }
    const ot = calcVariableComponent("OVERTIME", paystubYTD.overtimeYTD, (y) => y.overtime);
    monthlyOvertime = ot.monthly;
    if (ot.trend.status === "DECLINING") flags.push({ severity: "warn", code: "OT_DECLINING", message: "Overtime trend appears declining; additional analysis required." });
    breakdown.push({ type: "OVERTIME", amount: monthlyOvertime, note: ot.note });
  }

  // Bonus
  let monthlyBonus = 0;
  if (paystubYTD.bonusYTD > 0) {
    if (priorYears.length === 0) {
      flags.push({ severity: "warn", code: "BONUS_HISTORY_UNKNOWN", message: "Bonus present but no prior year provided; underwriting may require history." });
    }
    const b = calcVariableComponent("BONUS", paystubYTD.bonusYTD, (y) => y.bonus);
    monthlyBonus = b.monthly;
    if (b.trend.status === "DECLINING") flags.push({ severity: "warn", code: "BONUS_DECLINING", message: "Bonus trend appears declining; additional analysis required." });
    breakdown.push({ type: "BONUS", amount: monthlyBonus, note: b.note });
  }

  // Commission
  let monthlyCommission = 0;
  if (paystubYTD.commissionYTD > 0) {
    if (priorYears.length < 1) {
      flags.push({ severity: "warn", code: "COMM_HISTORY_SHORT", message: "Commission income typically requires history; provide prior year(s) for trending." });
    }
    const c = calcVariableComponent("COMMISSION", paystubYTD.commissionYTD, (y) => y.commission);
    monthlyCommission = c.monthly;
    if (c.trend.status === "DECLINING") flags.push({ severity: "warn", code: "COMM_DECLINING", message: "Commission trend appears declining; additional analysis required." });
    breakdown.push({ type: "COMMISSION", amount: monthlyCommission, note: c.note });
  }

  const monthlyTotal = monthlyBase + monthlyOvertime + monthlyBonus + monthlyCommission;

  // Continuity reminder flag (B3-3.1-01)
  // If you later add an “expiration date” input, elevate this to stop/warn based on <3 years.
  flags.push({
    severity: "info",
    code: "CONTINUITY",
    message: "Income used must be stable/predictable and likely to continue; document defined expirations when applicable."
  });

  return {
    monthlyBase,
    monthlyOvertime,
    monthlyBonus,
    monthlyCommission,
    monthlyTotal,
    breakdown,
    flags
  };
}